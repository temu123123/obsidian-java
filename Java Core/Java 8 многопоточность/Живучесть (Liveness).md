### Взаимная блокировка (Deadlock)

**Взаимная блокировка** (deadlock) описывает ситуацию, когда два или более потока блокируются навсегда, каждый ожидая другого.
### Голодание (starvation)

**Голодание** (starvation) описывает ситуацию, когда поток не может получить доступ к совместно используемым ресурсам и не может продвинуться в своём выполнении дальше. Это возникает, когда совместно используемый ресурс делается недоступным на долгое время «жадными» потоками. Например, предположим, что объект предоставляет синхронизированный метод, который обычно выполняется достаточно долго. Если один поток вызывает этот метод часто, то другие потоки, которым тоже нужен частый синхронизированный доступ к тому же самому объекту, будут часто блокироваться.

### Активная блокировка (livelock)

Поток часто реагирует на события из другого потока. Если действие другого потока тоже является ответом на событие из другого потока, то может произойти **активная блокировка** (livelock). Как и взаимная блокировка (deadlock), активно заблокированные потоки не могут продвинуться дальше в своём выполнении. Однако эти потоки не заблокированы — они просто слишком заняты, отвечая друг другу, чтобы вернуться к работе. Это можно сравнить с двумя людьми, которые пытаются пройти через друг друга в коридоре: Алиса двигается влево, чтобы Боб мог пройти, в это же время Боб двигается вправо, чтобы Алиса могла пройти. Видя, что они всё ещё блокируют друг друга, Боб двигается влево, а Алиса вправо, но они всё ещё блокируют друг друга.

## Защищённые блокировки (guarded blocks)

Потокам зачастую приходится согласовывать свои действия. Наиболее часто используемый способ согласования — защищённые блокировки (guarded blocks). Такой блок начинается с выбора условия, которое должно быть true, перед тем как может осуществиться блокировка.
## Неизменяемые объекты (immutable objects)

Объект считается неизменяемым, если его внутреннее состояние не может быть изменено после создания. Использование неизменяемых объектов — широко распространённая стратегия для создания простого и надёжного кода.

Неизменяемые объекты особенно полезны в многопоточных приложениях. Так как они не могут менять своего внутреннего состояния, то они не могут быть испорчены вмешательством в поток (thread interference) или прочитаны в некорректном состоянии.

Программисты часто ленятся использовать неизменяемые объекты, так как они беспокоятся о цене создания нового объекта вместо изменения старого. Влияние создания экземпляров объектов часто переоценивается и может быть компенсировано преимуществами использования неизменяемых объектов.
## Высокоуровневые объекты для многопоточного приложения

До сих пор мы обсуждали низкоуровневое [API](https://urvanov.ru/2015/11/15/api-application-programming-interface/), которое было частью Java с самого начала. Это API подходит для очень простых задач, но для более сложных задач нужно что-нибудь более высокоуровневое. Это особенно важно для больших многопоточных приложений, которые полностью используют современные системы с несколькими процессорами и несколькими ядрами.

### Объекты Lock

Синхронизированный код полагается на простой тип reentrant lock (блокировка, которую можно брать несколько раз). Этот тип легко использовать, но он имеет определённые ограничение. Более сложные способы блокировки поддерживаются пакетом [java.util.concurrent.locks](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/package-summary.html). Этот пакет имеет довольно много классов, но здесь будет рассмотрен его наиболее базовый интерфейс [Lock](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Lock.html).

Объекты Lock  работают очень похоже на внутренние блокировки, используемые синхронизированным кодом. Так же как и для внутренних блокировок только один поток может держать блокировку объекта Lock  в одно время. Объекты Lock  также поддерживают механизм wait / notify  через ассоциированные с ними объекты [Condition](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/locks/Condition.html).

Преимущество объектов Lock  над внутренними блокировками в том, что они могут отказаться от участия в попытке приобрести блокировку. Метод tryLock  сразу же завершается, если блокировка недоступна сразу же, либо после истечения указанного времени (если время указано). Метод lockInterruptibly  отказывается от попытки получить блокировку, если другой поток отправляет interrupt  до получения блокировки.